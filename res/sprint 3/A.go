/*
https://contest.yandex.ru/contest/23815/run-report/110177404/

-- ПРИНЦИП РАБОТЫ --
	Сразу отрабатываются варианты когда длинна массива 0, 1 или 2.
Я решил найти индекс элемента с наименьшим значением. Реализовал это бинарным поиском. Создал указатели left И right.
Получаю середину от суммы left И right. Если элемент середины скньше предыдущего элемента, то это и есть индекс элемента с наименьшим значением.
Иначе увеличиваю left или уменьшаю right в зависимости от того какой элемент больше.
	После того, как я нашел индекс минимального значения, я проверил в какой части от минимального значения лежит искомое значение.
Реализовал механизм как в поиске индекса минимального значения, только средний элемент сравнивал не с предыдущим, а с заданным значением.
Если не равен, то увеличиваю left или уменьшаю right в зависимости от того какой̆ элемент больше.

-- ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ --
Из описания алгоритма следует, что элемент с необходимым значением находится. Если искомое значение отсутствует, то возвращается -1

-- ВРЕМЕННАЯ СЛОЖНОСТЬ --
Поиск индекса элемента O(log N) где N это количество элементов массива, я не обхожу весь массив.
Я дважды обхожу массив, но с каждым шагом я беру только половину от полученного подмассива.

-- ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ --
Т.к. никаких действий с массивом я не делаю, то в памяти будет занимать n элементов массива и манятся не будет.

*/

package main

func brokenSearch(arr []int, k int) int {
	if len(arr) == 0 {
		return -1
	}
	if len(arr) == 1 {
		if arr[0] == k {
			return 0
		}
		return -1
	}
	if len(arr) == 2 {
		if arr[0] == k {
			return 0
		} else if arr[1] == k {
			return 1
		}
		return -1
	}

	//Определяю индекс минимального значения
	middle := -1
	left, right := 0, len(arr)-1
	for left < right {
		middle = (left + right) / 2

		if middle-1 >= 0 && arr[middle] < arr[middle-1] {
			break
		}
		if arr[middle] >= arr[0] {
			left = middle + 1
			continue
		}

		right = middle
	}
	left, right = 0, middle

	//определяяю в какой части массива от минимального значения искомое значение
	leftPart := k >= min(arr[0], arr[middle-1]) && k <= max(arr[0], arr[middle-1])
	if !leftPart {
		left, right = middle, len(arr)
	}

	for left < right {
		middle = (left + right) / 2

		if arr[middle] == k {
			break
		}

		if arr[middle] < k {
			left = middle + 1
			continue
		}

		right = middle
	}

	if arr[middle] != k {
		return -1
	}
	return middle
}
