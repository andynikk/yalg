/*
https://contest.yandex.ru/contest/25597/run-report/114040019/

-- ПРИНЦИП РАБОТЫ --
Алгоритм реализует поиск расстояния Левенштейна между двумя строками с использованием динамического программирования.
	В функции я получаю входные данные. Создаю два массива с данными s и t. Создаю матрицу dp размером (len(s)+1) на 2, где первый столбец и первая строка инициализируются значениями от 0. И заполняю в глубину до длины строки s.
	В функции distance передаю матрицу dp, представляющую таблицу для хранения результатов промежуточных вычислений, а также массивы строк s и t, между которыми нужно найти расстояние Левенштейна.
	Вложенными циклами перебираю все элементы матрицы dp, начиная с единицы, и для каждой ячейки вычисляется минимальное значение. Матрица имеет всего две "колонки". Т.к. для расчета необходимо только текущая "колонка" и предыдущая.
После заполнения текущей ячейки, я значение предыдущей ячейки переношу в соответствующую строку, предыдущей "колики", т.к. ее значение меня больше не интересует. После прохождения по всей "колонке", я так же, значение последней, правой ячейки переношу влево.
	Операции вставки, удаления и замены символов учитываются при вычислении коэффициента, который равен 1, если символы в позициях i-1 и j-1 не совпадают.
	Значение в каждой ячейке матрицы dp вычисляю как минимум из трех значений: предыдущее значение плюс 1 (удаление), текущее значение плюс 1 (вставка), или значение на диагонали плюс коэффициент (замена).

-- ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ --
	Инициализация матрицы dp. Я установил значения в первой строке и первом столбце соответственно от 0 до длины соответствующих строк. Это базовый случай для дальнейших вычислений.
	Для каждой ячейки матрицы dp, кроме первой строки и первого столбца, я вычисляю значение, основываясь на значениях предыдущих ячеек. Рекуррентное соотношение учитывает три возможных операции: вставка, удаление и замена символа. Мы выбираем минимальное из этих трех значений для каждой ячейки.
	Функция distance правильно вычисляет расстояние Левенштейна между подстроками s[:i] и t[:j]. Это следует из того, что я использую рекурсивное соотношение, которое учитывает все возможные варианты преобразований подстрок.
	После завершения заполнения матрицы dp, значение в левом нижнем углу будет представлять искомое расстояние Левенштейна между строками s и t.
	Таким образом, код работает корректно благодаря использованию динамического программирования и правильному обновлению значений в матрице dp.

-- ВРЕМЕННАЯ СЛОЖНОСТЬ --
	m — длина первой строки
	n - длина второй строки
	Алгоритма нахождения расстояния Левенштейна с использованием динамического программирования обычно составляет O(m*n). Это происходит из-за заполнения матрицы размером (m+1) на (n+1) и выполнения операций в каждой ячейке этой матрицы.
Итоговая сложность: O(m*n)

-- ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ --
	m — длина первой строки
	n - длина второй строки

 	Сложность матрицы dp составляет O(2m), так как я использую матрицу размером (m+1) x 2 для расчета и хранения промежуточных результатов.
	Также в памяти хранятся массивы строк m и n O(n), O(m)
Итоговая сложность: O(2m)+O(m)+O(n) или O(3m+n)

*/

package main

import (
	"os"
	"strconv"
	"strings"
)

func main() {
	res, err := inputTxt()
	if err != nil {
		panic(err)
	}

	r := Levenshtein(&res)

	err = outputStr(&r)
}

func inputTxt() ([]byte, error) {
	res, err := os.ReadFile("input.txt")
	return res, err
}

func outputStr(r *string) error {

	file, err := os.Create("output.txt")
	if err != nil {
		return err
	}
	file.WriteString(*r)
	return nil

}

func distance(dp [][2]int, s, t []string) int {
	for j := 1; j < len(t)+1; j++ {
		for i := 1; i < len(s)+1; i++ {
			dp[0][1] = j
			coefficient := 0
			if s[i-1] != t[j-1] {
				coefficient = 1
			}

			dp[i][1] = min(dp[i-1][1]+1, dp[i][0]+1, dp[i-1][0]+coefficient)
			dp[i-1][0] = dp[i-1][1]
		}
		dp[len(s)][0] = dp[len(s)][1]
	}

	return dp[len(s)][0]
}

func Levenshtein(res *[]byte) string {

	lines := strings.Split(string(*res), "\n")

	s := strings.Split(lines[0], "")
	t := strings.Split(lines[1], "")

	if len(s) > len(t) {
		s, t = t, s
	}

	dp := make([][2]int, len(s)+1)
	for i := 0; i < len(s)+1; i++ {
		dp[i][0] = i
	}

	return strconv.Itoa(distance(dp, s, t)) + "\n"
}
